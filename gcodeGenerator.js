(function (global) {
  const DEFAULT_DECIMALS = 3;

  class GCodeGenerator {
    constructor(options = {}) {
      const defaults = {
        toolName: "LineMaker",
        canvasWidth: null,
        canvasHeight: null,
        feedRate: 1500,
        penUpZ: 2,
        penDownZ: 0,
        preventZhop: 0,
        startX: 0,
        startY: 0,
        decimals: DEFAULT_DECIMALS,
        metricUnits: true,
        absolutePositioning: true,
        includeHome: true,
        homeCommand: "G28 ; Home all axes",
        liftCommand: "G0",
        plungeCommand: "G1",
        headerLines: [],
        footerLines: [],
      };

      this.options = { ...defaults, ...options };
      this.commands = [];
      this.currentX = this.options.startX;
      this.currentY = this.options.startY;
      this.penState = "up";
      this.programBegan = false;
      this.programFinished = false;
      this.feedRate = this.options.feedRate;
    }

    beginProgram(meta = {}) {
      if (this.programBegan) return;

      const toolName = meta.toolName || this.options.toolName;
      const headerLines = [];

      if (toolName) headerLines.push(`Generated by ${toolName}`);

      const canvasWidth = meta.canvasWidth ?? this.options.canvasWidth;
      const canvasHeight = meta.canvasHeight ?? this.options.canvasHeight;
      if (this.isFiniteNumber(canvasWidth) && this.isFiniteNumber(canvasHeight)) {
        headerLines.push(`Canvas size: ${canvasWidth}mm x ${canvasHeight}mm`);
      }

      if (Array.isArray(this.options.headerLines)) {
        headerLines.push(...this.options.headerLines.map(String));
      }
      if (Array.isArray(meta.headerLines)) {
        headerLines.push(...meta.headerLines.map(String));
      }

      headerLines.forEach((line) => this.addComment(line));

      if (this.options.metricUnits) {
        this.addCommand("G21", "Set units to millimeters");
      }
      if (this.options.absolutePositioning) {
        this.addCommand("G90", "Use absolute coordinates");
      }
      if (this.options.includeHome && this.options.homeCommand) {
        this.commands.push(this.options.homeCommand);
      }

      const penUpZ = meta.penUpZ ?? this.options.penUpZ;
      if (this.isFiniteNumber(penUpZ)) {
        const feed = this.feedRate ? ` F${this.formatNumber(this.feedRate)}` : "";
        this.addCommand(
          `${this.options.liftCommand} Z${this.formatNumber(penUpZ)}${feed}`,
          "Pen up"
        );
      }

      this.programBegan = true;
    }

    finishProgram(meta = {}) {
      if (this.programFinished) return;
      if (!this.programBegan) this.beginProgram(meta);

      const penUpZ = meta.penUpZ ?? this.options.penUpZ;
      if (this.isFiniteNumber(penUpZ)) {
        this.ensurePenUp({ force: true, penUpZ });
      }

      const footerLines = [];
      if (Array.isArray(this.options.footerLines)) {
        footerLines.push(...this.options.footerLines);
      }
      if (Array.isArray(meta.footerLines)) {
        footerLines.push(...meta.footerLines);
      }

      footerLines.forEach((line) => {
        if (typeof line === "function") {
          const resolved = line(this);
          if (resolved) this.commands.push(resolved);
        } else if (line) {
          this.commands.push(String(line));
        }
      });

      this.programFinished = true;
    }

    addComment(text) {
      if (!text) return;
      this.commands.push(`; ${text}`);
    }

    addCommand(command, comment) {
      if (!command) return;
      if (comment) {
        this.commands.push(`${command} ; ${comment}`);
      } else {
        this.commands.push(command);
      }
    }

    ensurePenUp(options = {}) {
      const penUpZ = this.isFiniteNumber(options.penUpZ)
        ? options.penUpZ
        : this.options.penUpZ;
      if (this.penState !== "up" || options.force) {
        let feed;
        if (this.isFiniteNumber(options.feedRate)) {
          feed = Number(options.feedRate);
        } else if (this.penState === "down" && this.isFiniteNumber(this.feedRate)) {
          feed = this.feedRate;
        }
        const feedSuffix = this.isFiniteNumber(feed)
          ? ` F${this.formatNumber(feed)}`
          : "";
        this.addCommand(
          `${this.options.liftCommand} Z${this.formatNumber(penUpZ)}${feedSuffix}`,
          options.comment || "Pen up"
        );
        this.penState = "up";
      }
    }

    ensurePenDown(options = {}) {
      const penDownZ = this.isFiniteNumber(options.penDownZ)
        ? options.penDownZ
        : this.options.penDownZ;
      if (this.penState !== "down") {
        const feed = options.feedRate || this.feedRate;
        const feedSuffix = this.isFiniteNumber(feed)
          ? ` F${this.formatNumber(feed)}`
          : "";
        this.addCommand(
          `${this.options.plungeCommand} Z${this.formatNumber(penDownZ)}${feedSuffix}`,
          options.comment || "Pen down"
        );
        this.penState = "down";
      }
    }

    moveTo(x, y, options = {}) {
      if (!this.isFiniteNumber(x) || !this.isFiniteNumber(y)) return;

      const rapid = options.rapid ?? this.penState !== "down";
      const commandType = rapid ? "G0" : "G1";
      const feed = options.feedRate;
      const feedSuffix = this.isFiniteNumber(feed)
        ? ` F${this.formatNumber(feed)}`
        : "";

      this.addCommand(
        `${commandType} X${this.formatNumber(x)} Y${this.formatNumber(y)}${feedSuffix}`,
        options.comment
      );

      this.currentX = x;
      this.currentY = y;
    }

    drawLineTo(x, y, options = {}) {
      if (!this.isFiniteNumber(x) || !this.isFiniteNumber(y)) return;
      if (!this.programBegan) this.beginProgram();

      const feed = options.feedRate || this.feedRate;
      const feedSuffix = this.isFiniteNumber(feed)
        ? ` F${this.formatNumber(feed)}`
        : "";

      this.ensurePenDown(options);
      this.addCommand(
        `G1 X${this.formatNumber(x)} Y${this.formatNumber(y)}${feedSuffix}`,
        options.comment || "Draw"
      );

      this.currentX = x;
      this.currentY = y;
    }

    drawPolyline(points, options = {}) {
      if (!Array.isArray(points) || points.length < 2) return;
      if (!this.programBegan) this.beginProgram();

      const epsilon = options.epsilon ?? 0.001;
      const preventZhop = options.preventZhop ?? this.options.preventZhop;
      const feedRate = options.feedRate || this.feedRate;

      const firstPoint = points[0];
      if (!this.isFiniteNumber(firstPoint.x) || !this.isFiniteNumber(firstPoint.y)) {
        return;
      }

      const distanceToStart = GCodeGenerator.distance(
        this.currentX,
        this.currentY,
        firstPoint.x,
        firstPoint.y
      );

      if (distanceToStart > epsilon) {
        const shouldLift = this.penState === "down" && distanceToStart > preventZhop;
        if (shouldLift) {
          this.ensurePenUp({ force: true });
        }

        this.moveTo(firstPoint.x, firstPoint.y, {
          rapid: this.penState !== "down",
          comment: this.penState === "down" ? "Drag to start" : "Move to start",
          feedRate: this.penState === "down" ? feedRate : undefined,
        });
      }

      this.ensurePenDown({ feedRate, penDownZ: options.penDownZ, comment: options.penDownComment });

      for (let i = 1; i < points.length; i++) {
        const point = points[i];
        if (!this.isFiniteNumber(point.x) || !this.isFiniteNumber(point.y)) continue;
        this.drawLineTo(point.x, point.y, {
          feedRate,
          comment: options.segmentComment,
        });
      }

      if (options.autoLift) {
        this.ensurePenUp({ feedRate, comment: options.penUpComment });
      }
    }

    renderLineSegments(lines, options = {}) {
      if (!Array.isArray(lines) || lines.length === 0) return;

      const startX = this.isFiniteNumber(options.startX) ? options.startX : this.currentX;
      const startY = this.isFiniteNumber(options.startY) ? options.startY : this.currentY;
      const preventZhop = options.preventZhop ?? this.options.preventZhop;
      const feedRate = options.feedRate || this.feedRate;

      let segments = lines;
      if (options.optimize !== false) {
        segments = GCodeGenerator.optimizeLineOrder(lines, startX, startY);
      }

      const epsilon = options.epsilon ?? 0.001;

      segments.forEach((segment) => {
        if (!segment) return;
        const { x1, y1, x2, y2 } = segment;
        if (
          !this.isFiniteNumber(x1) ||
          !this.isFiniteNumber(y1) ||
          !this.isFiniteNumber(x2) ||
          !this.isFiniteNumber(y2)
        ) {
          return;
        }

        const moveDistance = GCodeGenerator.distance(this.currentX, this.currentY, x1, y1);
        if (moveDistance > epsilon) {
          const shouldLift = this.penState === "down" && moveDistance > preventZhop;
          if (shouldLift) {
            this.ensurePenUp({ force: true, feedRate });
          }

          const rapid = this.penState !== "down";
          this.moveTo(x1, y1, {
            rapid,
            comment: rapid ? "Move to start" : "Drag to start",
            feedRate: rapid ? undefined : feedRate,
          });
        }

        this.ensurePenDown({ feedRate });
        this.drawLineTo(x2, y2, {
          feedRate,
          comment: segment.comment || "Draw line",
        });
      });
    }

    toString() {
      return this.commands.join("\n");
    }

    formatNumber(value) {
      const number = Number(value);
      if (!Number.isFinite(number)) {
        return (0).toFixed(this.options.decimals);
      }
      return number.toFixed(this.options.decimals);
    }

    isFiniteNumber(value) {
      return Number.isFinite(Number(value));
    }

    static distance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    static optimizeLineOrder(lines, startX = 0, startY = 0) {
      if (!Array.isArray(lines) || lines.length <= 1) return lines ? [...lines] : [];

      const remaining = lines.map((line) => ({ ...line }));
      const optimized = [];
      let currentX = startX;
      let currentY = startY;

      while (remaining.length > 0) {
        let bestIndex = 0;
        let bestDistance = Infinity;
        let bestReversed = false;

        for (let i = 0; i < remaining.length; i++) {
          const line = remaining[i];
          if (!line) continue;
          const distToStart = GCodeGenerator.distance(currentX, currentY, line.x1, line.y1);
          if (distToStart < bestDistance) {
            bestDistance = distToStart;
            bestIndex = i;
            bestReversed = false;
          }

          const distToEnd = GCodeGenerator.distance(currentX, currentY, line.x2, line.y2);
          if (distToEnd < bestDistance) {
            bestDistance = distToEnd;
            bestIndex = i;
            bestReversed = true;
          }
        }

        const bestLine = remaining.splice(bestIndex, 1)[0];
        if (!bestLine) continue;

        if (bestReversed) {
          const reversed = {
            ...bestLine,
            x1: bestLine.x2,
            y1: bestLine.y2,
            x2: bestLine.x1,
            y2: bestLine.y1,
          };
          optimized.push(reversed);
          currentX = reversed.x2;
          currentY = reversed.y2;
        } else {
          optimized.push(bestLine);
          currentX = bestLine.x2;
          currentY = bestLine.y2;
        }
      }

      return optimized;
    }
  }

  global.GCodeGenerator = GCodeGenerator;
})(typeof window !== "undefined" ? window : globalThis);
